### 一、TCP/IP结构 以及 TCP 与 UDP知识：

##### （一）TCP/IP 结构

1. TCP/IP基本结构：

   TCP/IP相对于OSI七层模型来说，更简洁。它把整个OSI七层模型分成了4个部分，分别是：

   - 网络接口层：物理层+数据链路层
   - 网际层：网络层（IP层）
   - 传输层：传输层
   - 应用层：会话层+表示层+应用层

   相对应的功能如下：

   - 网络接口层：
   - 网际层：将分组发往任何网络，但是不保证有序达到目的地。有序性的事情交给上层。
   - 传输层：进行实体会话。也就是端口和端口之间的连接
   - 应用层：高层协议

2. IP——网络层协议：

   功能：

   - 确定IP分组 以及 其数据格式
   - 规定分组如何处理
   - 任务是：仅仅根据源主机和目的主机的地址传送数据

3. 传输层协议基础知识：

   - 功能：

     - 实现端到端通信（也就是主机进程和主机进程之间的通信）
     - 对报文进行差错检测

   - 套接字：（socket）

     也就是：IP地址 + 端口号

4. UDP 协议：

   UDP 是那种做最少的工作去达到传输目的的一种协议。选择了UDP，意味着几乎直接与IP打交道。

   UDP有下面的几个特点：

   - 面向无连接：连接会造成时延。
   - 更好地去控制数据发送的时间。UDP没有拥塞机制，不会影响主机的发送效率。
   - UDP提供尽最大努力的交付，不能够保证可靠的交付。
   - UDP面向报文：报文是UDP的最小处理单位。
   - UDP 没有连接状态

   适合一次性传输较少数据的网络应用。

5. TCP协议：

   （1）特点：

   - TCP 是面向连接的传输层协议，每条连接只能有两个端点
   - 提供可靠的交付服务，保证 无差错、不丢失、不重复、有序
   - 提供全双工通信，两端都有缓存，来临时存放通信数据。
   - 面向字节流：

   （2）TCP 连接建立过程：三次握手：

   - step1：

     客户 向 服务器 发送一个需要连接的请求。这个报文中，SYN=1

   - step2：

     服务器 收到请求，如果同意，那么就向 客户 发送确认信息，并且在 server 端 为 TCP连接分配资源。确认报文中，ACK=1，SYN=1。

   - step3：

     客户机收到 server 的回应之后，向服务器发出确认信息，告诉服务器知道 收到了确认信息。并分配资源。

   **注意：**

   第三次握手的时候，可以携带需要传输的数据。前两次握手不能携带数据。

   - 两次握手不可取：

     如果是两次，你现在发了 SYN 报文想握手，但是这个包**滞留**在了当前的网络中迟迟没有到达，TCP 以为这是丢了包，于是重传，两次握手建立好了连接。

     看似没有问题，但是连接关闭后，如果这个**滞留**在网路中的包到达了服务端呢？这时候由于是两次握手，服务端只要接收到然后发送相应的数据包，就默认**建立连接**，但是现在客户端已经断开了。

   - 四次呢？

     三次就做好的事情为什么要做四次。。。

   （3）TCP连接断开：四次挥手

   - step1：

     客户准备断开连接，向 server 发送断开连接的请求，停止发送数据。这个时候客户不能发数据了。

   - step2：

     服务器收到断开连接的请求，发出ACK=1的报文，告诉对方知道了，发送断开 客户—>server 的连接，变成半双工。

   - step3：

     server 看有没有还没有发完的数据，有的话，继续发给 客户。

     没有，那么通知 TCP释放连接，发出 FIN = 1的报文。（俺完事了，看你的了）

   - step4：

     客户收到 刚刚释放连接的报文，发出确认报文，ACK=1，等待计时器设置的时间 2MSL 之后，server —> 客户机 的连接也关闭了。在这个 2MSL 中，如果客户端没有收到服务端的重发请求，那么表示 ACK 成功到达，挥手结束。

   （4）为什么要等待 2MSL？

   - 防止客户端最后一次发给服务器的确认在网络中丢失以至于客户端关闭，而服务端并未关闭，导致资源的浪费。
   - 让本次连接的所有的网络包在链路上消失，以防造成不必要的干扰。

   2MSL：4min

   （5）流量控制：

   过程如下：

   - 1：各自初始化缓存区大小和窗口大小。都是200。

   - 2：

     - 发的人：（send）我发了100个字节的东西，对方没告诉我这100个现在什么情况。

     - 接收者：（receive）我收到了100个字节的，但是我现在只能处理40个，还有60个存起来啦，不给你确认。

       告诉 send：我收到了40B，现在我收不了那么多，你窗口小点，大概还能发140吧。

     - 发的人：（send）okk，我向前窗口滑动40（反正都搞完了），然后窗口现在大小140（最多还能继续发**新的**140的东西）

   （6）拥塞机制：

   - 1：拥塞机制的基本概念

     - 接收窗口：和前面一样，接收方允许发送数据的多少。
     - 拥塞窗口：自己还能传输的数据量大小。

   - 2：慢启动算法

     - 首先 拥塞窗口 cwnd=1，每经过一个 RTT，如果收到的都是确定的ACK，那么cwnd增加之前的收到的ACK数量。类似于2^n的增长。也就是说：

       cwnd=1，之后收到1个ACK，cwnd=1+1=2，之后RTT过后，收到2个ACK（刚刚发出去两个），cwnd=4……

   - 3：拥塞避免算法：

     - 首先设定一个阈值，到达那个阈值的时候，选择每次cwnd++，呈线性增长。
     - 如果出现了拥塞，那么 阈值=当前cwnd/2，cwnd=1，继续慢开始。

   - 4：快重传

     有时候出现一些问题，比如丢包啦，这个时候比如丢了第5个包，那么接收方会一直发4的ACK，连续收到三次这样的ACK之后，发送方明白了：5丢掉了，不必等待就可以发送5

   - 5：快恢复：

     发现有丢包了？可能网络有点堵了。

     - 拥塞阈值降低为 cwnd 的一半
     - cwnd 的大小变为拥塞阈值
     - cwnd 线性增加



### 二、HTTP相关知识：

1. HTTP 的请求方法：

   - GET: 通常用来获取资源
   - POST: 提交数据，即上传数据(可能会造成修改)
   - PUT: 修改数据
   - DELETE: 删除资源(几乎用不到)

   一些其他的：

   - HEAD: 获取资源的元信息（类似于GET，但是返回的没有主体，只有报头）
   - CONNECT: 建立连接隧道，用于代理服务器
   - OPTIONS: 列出可对资源实行的请求方法，用来跨域请求（看看有什么？
   - TRACE: 追踪请求-响应的传输路径

   其中，GET\POST\HEAD 是1.0 的，剩下的是1.1的。

   - GET 和 POST 的区别？
     - **缓存**的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。
     - **编码**的角度，GET 只能接收 ASCII 字符，而 POST 没有限制。
     - **TCP**的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。

2. HTTP报文结构：

   HTTP报文有两种：

   - 客户 —> server ：请求报文
   - server —> 客户：响应报文

   其中：

   - 请求报文：

     请求行 ===> 请求头 ===> 实用主体

     - 请求行：

       方法 + URL + HTTP版本 

   - 响应报文：

     状态行 ===> 响应头 ===> 实用主体

     - 状态行：

       HTTP版本 + 状态码 + 原因

3. URL 的结构：

   例如 下面的地址：

   https://www.baidu.com/s?ie=utf-8&f=8&rsv_bp=1&rsv_idx=2

   https ：协议名

   www.baidu.com ：主机名

   :8080 ：端口号

   /xxx/yyy：路径

   ? key=val & key2=val2 ：？后面是需要传递的一些查询参数，之前用 & 分开

4. HTTP 状态码：

   每种都有开头：

   1xx：目前是协议处理的中间状态，还需要后续操作。

   2xx：成功

   3xx：重定向，资源位置变动

   - 304：协商缓存

   4xx：报文出错

   - 403：服务器禁止访问
   - 404： 资源未找到
   - 405：请求方法不被服务器端允许
   - 408：服务器等待时间太长

   5xx：服务器端发生错误

   - 503：服务器忙

5. 关于 Cookie：

   HTTP 是不带有状态的。但是有的时候，我们希望能够知道一些状态，这个时候在浏览器内部，会创建一个文本，来记录服务器 和 客户的状态。Cookie有这样几个属性：

   - 生存周期：

     - MaxAge：一段时间间隔，单位为 秒，从浏览器收到报文开始计算
     - Expires：过期时间

     当时间到了的时候，这个 Cookie 会被删除，并不会发送给服务端

   - 作用域

   - 安全相关：

     - Secure：只能通过 HTTPS 传输 cookie。
     - HttpOnly：那么说明只能通过 HTTP 协议传输，不能通过 JS 访问

6. 关于跨域请求：

   浏览器为了安全起见，面对跨域请求，浏览器会自己屏蔽掉这个信息。

   跨域请求是什么？ 当协议名+域名+端口号 相同的时候，这个请求是同一个域的，只要有一个不同，就是跨域。

   那么跨域的整个过程是什么样的？这就要区分一下简单请求和复杂请求了。

   - 简单请求：

     - 请求方法为 GET、POST 或者 HEAD
     - 请求头的取值范围: Accept、Accept-Language、Content-Language、Content-Type(只限于三个值`application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`)

     简单请求，浏览器将请求发送给服务器，其中：

     - 浏览器：Origin`字段，用来说明请求来自哪个`源

     - 服务器会在回应的报文中，响应头有这几个参数：

       - `Access-Control-Allow-Origin`字段：如果`Origin`不在这个字段的范围中，那么浏览器就会将响应拦截。

       - 其它一些可选的功能性的字段，用来描述如果不会拦截，这些字段将会发挥各自的作用。

       - Access-Control-Allow-Credentials：这个字段是一个布尔值，表示是否允许发送 Cookie，对于跨域请求，浏览器对这个字段默认值设为 false。

         如果需要拿到浏览器的 Cookie，需要添加这个响应头并设为`true`, 并且在前端也需要设置`withCredentials`属性。

   - 非简单请求：

     上述情况不满足的都是非简单请求。

     其中处理过程如下所示：

     - **预检请求**：

       发出去一个请求之后，实际上，会先发送预检请求，方法是 OPTIONS，并且加上两个关键字段：

       - Access-Control-Request-Method, 列出 CORS 请求**用到哪个HTTP方法**
       - Access-Control-Request-Headers，指定 CORS 请求**将要加上什么请求头**

     - 接下来是服务器的响应：

       这里会是两部分：

       对预检请求的响应：

       - Access-Control-Allow-Origin: 表示可以允许请求的源，可以填具体的源名，也可以填`*`表示允许任意源请求。
       - Access-Control-Allow-Methods: 表示允许的请求方法列表。
       - Access-Control-Max-Age: 预检请求的有效期，在此期间，不用发出另外一条预检请求。

       如果请求不满足响应头的条件，则触发`XMLHttpRequest`的`onerror`方法，当然后面真正的**CORS请求**也不会发出去了。

       如果满足（在允许的域内），则会执行第二部分：

       对跨域请求的响应：

       - 和简单请求一样，浏览器自己加上origin字段，表明自己的身份；服务端响应头返回**Access-Control-Allow-Origin**。

7. 跨域解决方案：

   有两种，可以使用JSONP，也可以使用Nginx 进行反向代理：

   - JSONP：

     虽然`XMLHttpRequest`对象遵循同源政策，但是`script`标签不一样，它可以通过 src 填上目标地址从而发出 GET 请求，实现跨域请求并拿到响应。

   - Nginx：

     反向代理。反向代理帮**其它的服务器**拿到请求，然后选择一个合适的服务器，将请求转交给它。

     Nginx 相当于起了一个跳板机，这个跳板机的域名也是`client.com`，让客户端首先访问 `client.com/api`，这当然没有跨域，然后 Nginx 服务器作为反向代理，将请求转发给`server.com`，当响应返回时又将响应给到客户端，这就完成整个跨域请求的过程。

8. HTTPS——TLS握手过程：

    HTTP 是明文传输的协议，传输保文对外完全透明，非常不安全。我们如何保证安全性呢？

   那么HTTPS来了。HTTPS=HTTP+SSL/TLS。

   传统的 HTTPS是怎么实现的呢？——RAS加密

   - 其实HTTPS就是在HTTP和TCP两层中间加入了一层加密层。

     首先理解一下 对称加密 和 非对称加密：

     - 对称加密：

       使用同样的秘钥进行加密和解密

     - 非对称加密：

       A加密 body，只能用B解密，不可以用A。而用B加密 body，那只能用A解密。

       但是计算量很大。

   - 下面梳理一下HTTP加密的过程：

     - step1：

       browser —> server：传递 cline_random，加密方法List

     - step2：

       server —> browser：传递 server_random，加密方法，公钥

     - step3：

       browser —> server：生成 pre_random，并且用公钥A加密（这里是非对称加密）。

     - step4：

       server：利用私钥B，解密出 pre_random，使用：pre，cline，server来生成秘钥。

   - 关于数字证书：

     有可能会出现DNS劫持的现象。那么？

     出现了数字证书。可以用于验证服务器的身份。

     一般需要一个第三方的授权机构，来颁发数字证书。

     - 数字证书的作用：

       证明自己的身份

       将 公钥传递给 browser。

     - 数字证书的验证过程：

       读取证书的明文内容，也就是指纹（表示证书信息的唯一参数），并且解密得到指纹hash值和hash函数，这样通过对明文信息使用hash函数，得到新的hash值。两个做对比，如果相同就验证成功了。

9. 关于 HTTP2：

   HTTPS 实际上解决了安全的问题。那么HTTP的改进就更侧重于性能的改进。

   它基本上使用了下面的一些优化：

   - 头部压缩：

     一般在HTTP中，会使用一些压缩算法来讲body中的编码进行压缩。但是请求头为什么不可以压缩呢？在GET请求头中，甚至都占用了整个报文的大部分地方。于是针对头部，HTTP2使用了HPACK进行压缩。

     HPACK 有两个特点：

     - 建立hash表，有的时候已经出现过的值，就可以用hash表的索引来表示。
     - 对于整数和字符串进行**哈夫曼编码**

     当然，HTTP/2 当中**废除了起始行的概念**，将起始行中的请求方法、URI、状态码转换成了**头字段**，不过这些字段都有一个":"前缀，用来和其它请求头区分开。

   - 服务器推送：

     服务器已经不再是完全被动地接收请求，响应请求，它也能新建 stream 来给客户端发送消息，当 TCP 连接建立之后，比如浏览器请求一个 HTML 文件，服务器就可以在返回 HTML 的基础上，将 HTML 中引用到的其他资源文件一起返回给客户端，减少客户端的等待。





### 三、浏览器缓存知识：

1. 基本概念：

   数据请求分为三个部分：

   - 发起网络请求
   - 后端处理（服务器？）
   - 浏览器响应

   缓存可以帮助我们去提高 step1 和 step3 的效率。比如：

   - 直接使用缓存而不发起请求
   - 发起了请求但后端存储的数据和前端一致。没有必要再将数据回传回来，这样就减少了响应数据。

   那么下面会说道一些基本概念：

   **缓存位置：**

   - Service Worker：

     运行在浏览器背后的独立线程，一般可以用来实现缓存功能。传输协议必须为 HTTPS。

     Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存**哪些文件**、如何**匹配缓存**、如何**读取缓存**，并且缓存是**持续性**的。

     实现的过程：<font color = green>（事件监听的模式？）</font>

     - 注册 Service Worker。
     - 监听到 install 事件，如果发生install事件，那么可以缓存需要的文件。
     - 下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。

     没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。

   - Memory Cache：

     是内存中的缓存。主要包含的是当前中页面中已经抓取到的资源，例如页面上已经下载的样式、脚本、图片等。

     内存缓存虽然读取高效，可是缓存持续性很短，会随着**进程**的**释放**而释放。

     **注意：**

     - 内存缓存在缓存资源时并不关心返回资源的HTTP缓存头Cache-Control是什么值。
     - 资源的匹配也并非仅仅是对URL做匹配，还可能会对Content-Type，CORS等其他特征做校验。

   - Disk Cache：

     硬盘中的缓存，读取速度慢，但是容量比较大，存储时间比较长。

     所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 **HTTP Herder** 中的字段判断**哪些资源需要缓存**，哪些资源**可以不请求直接使用**，哪些资源**已经过期需要重新请求**。

     在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。

     关于内存和硬盘中，一般哪些放在内存里面，哪些放在硬盘里面？

     - 对于大文件来说，大概率是不存储在内存中的，反之优先
     - 当前**系统内存使用率高**的话，文件优先存储进硬盘（内存空间比较小了）

   - Push Cache（推送缓存）：

     当以上三种缓存都没有命中时，它才会被使用。**它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂**，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。

2. 关于缓存的过程：

   现在问题来了：

   浏览器发起HTTP请求 – 服务器响应该请求，浏览器怎么确定一个资源该不该缓存，如何去缓存？

   **浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的**。

   下面给出一般的过程：

   ![avatar](F:\其他笔记\实习笔记-前端相关\计网复习-图片\浏览器缓存过程-1.PNG)

   也就是说，基本上是下面的规则和流程：

   - 浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识。
   - 浏览器每次拿到返回的请求结果都会将**该结果**和**缓存标识**存入浏览器缓存中。

   那么，下面我们需要搞懂的就是，**浏览器缓存的使用规则** 啦。

3. 浏览器缓存使用规则——强缓存：

   一般浏览器会先检查强缓存部分。

   强缓存部分**不会**向服务器发送**请求**，**直接**从**缓存中读取资源**。在chrome控制台的Network选项中可以看到该请求返回200的状态码，并且Size显示from disk cache或from memory cache。

   可以通过两种HTTP Header 实现：Expires 和 Cache-Control。

   - Expires ：

     缓存过期时间，用来指定资源到期的时间。

     Expires=max-age（可存留时长） + 请求时间（开始时间）。

     Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。

     受限于**本地时间**，如果修改了本地时间，可能会造成缓存失效。

   - Cache-Control：

     在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存。

     如当`Cache-Control:max-age=300`时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。（以秒计算）

     Cache-Control 可以在请求头或者响应头中设置。它除了max-age这个属性，还有很多属性。

   - 两者区别：

     差别不大，区别就在于 Expires 是http1.0的产物，Cache-Control是http1.1的产物，**两者同时存在的话，Cache-Control优先级高于Expires**。也就是说，Expires 已经过时了。

4. 浏览器缓存使用规则——协商缓存：

   但是强缓存是有时间限制的，而且也许在这个时间内，服务器文件已经变了。那怎么办呢？

   用到的就是协商缓存。

   协商缓存就是**强制缓存失效后**，浏览器**携带缓存标识**向服务器发起**请求**，由**服务器根据缓存标识决定是否使用缓存**的过程。

   有下面两种情况：

   - 协商缓存生效，返回304和Not Modified

     具体情况见下图：

     ![avatar](F:\其他笔记\实习笔记-前端相关\计网复习-图片\协商缓存-304.PNG)

   - 协商缓存失效，返回200和请求结果

     具体情况见下图：

     ![avatar](F:\其他笔记\实习笔记-前端相关\计网复习-图片\协商缓存-200.PNG)

   协商缓存会设置两种 HTTP Header：

   - Last-Modified：

     最后修改时间。在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段。

     如果再次请求，会在请求头中携带`If-Modified-Since`字段，这个字段的值也就是服务器传来的最后修改时间。

     服务器拿到请求头中的`If-Modified-Since`的字段后，其实会和这个服务器中 **该资源的最后修改时间** 对比:

     - 如果比它前，那么返回304
     - 如果比他后，那么200

   - ETag：

     服务器根据当前文件的内容，给文件生成的唯一标识，只要里面的内容有改动，这个值就会变。

     服务器通过`响应头`把这个值给浏览器。

     浏览器接收到`ETag`的值，会在下次请求时，将这个值作为**If-None-Match**这个字段的内容，并放到请求头中，然后发给服务器。

     收到**If-None-Match**后，会跟服务器上该资源的**ETag**进行比对:

     - 变了：200
     - 没变：304

   - 二者对比：

     - `精准度`上，`ETag`优于`Last-Modified`。
     - 在性能上，`Last-Modified`优于`ETag`，也很简单理解，`Last-Modified`仅仅只是记录一个时间点，而 `Etag`需要根据文件的具体内容生成哈希值。
     - 一般优先考虑 `Etag`。

